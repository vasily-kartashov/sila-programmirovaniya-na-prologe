# Многогранность Пролога

## Пролог --- очень простой язык

Довольно легко описать синтакс Пролога, в деталях достаточных для полноценной работы с языком. Все данные представлены термами. В языке существует единственная конструкция, назваемая !!утверждение!!. Утверждения имеют форму:

    Голова :- Тело.

Это значит, что если `Тело` верно, то и `Голова` тоже верна. Инфиксный оператор `:-/2` символизирует стрелочку показывающую налево: `←`. Если `Голова` верна всегда, то часть утверждения `:- Тело` может быть опущена.

И этого короткого описания уже достаточно, чтобы начать писать полезные программы на Прологе. Это может показаться невероятным, так что для убедительности упомянем, что _все_ программы представленные в этой книге состоят исключительно из утверждений. Более того, любое вычисление может быть представлено в форме утверждений, что делает Пролог [тьюринг-полным](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D0%B0_%D0%BF%D0%BE_%D0%A2%D1%8C%D1%8E%D1%80%D0%B8%D0%BD%D0%B3%D1%83) языком.

Чтобы смоделировать машину Тьюринга на Прологе, можно например описать все отношения между состояними машины с помощью _утверждений_ вида "если текущее состояние `S0`, и символ на ленте `T`, то слудующим состоянием будет `S`". Вы можете ознакомиться с имплементацией этой модели в [turing.pl](https://www.metalevel.at/prolog/showcases/turing.pl), и узнать больше про работу с состояним в Прологе в главе "[Работа с состояними]()".

## Пролог --- декларативный язык

Пролог --- декларативный язык. Это значит что мы сосредотачиваемся на описании того, что мы хотим найти. Мы стараемся выразить условия, которые отличают верные решения от неверных. Нам гораздо менее важно и интересно то, как Пролог будет находить эти решения.

Декларативная природа Пролога делает возможным написание очень чётких, ясных и универсальных определений. Маловероятно, что существует более короткий формализм, обладающий такой же ясностью и выразительностью как программы на Прологе.

Для примера опишем отношение между списком и его длинной, используя целочисленную арифметику:

    список_длинна([], 0).

    список_длинна([_|Ls], N) :-
        N #> 0,
        N #= N0 + 1,
        список_длинна(Ls, N0).

Возможно следующее декларативное прочтение:

- Длинна пустого списка `[]` равна `0` (также как и список длинны `0` пуст).
- Если длинна списка `Ls` равна `N0`, и `N` равна `N0 + 1`, тогда длинна списка `[_|Ls]` равна `N`. Это утверждение верно лишь для `N` строго больше нуля.

Про программировании на Прологе, важно думать в терминах отношений между элементами программы. С таким подходом к написанию программы получаются универсальными. Очень заманчиво назвать вышеприведённый пример "вычислением длинны списка". И в определённой мере это верно: мы можем использовать отношение `список_длинна` для вычисления длинны списка:

    ?- список_длинна([a, b, c], L).

    L = 3.

Однако подобное императивное прочтение слишком однобоко и недостаточно подчёркивает все возможности использования нашего определения. Например, если задать конкретную длинну списка, мы можем узнать, есть ли списки такой длинны:

    ?- список_длинна(Ls, 3).

    Ls = [_G1007, _G1087, _G1167] ;
    false.

Используя наиболее общий вопрос, мы даже можем найти все ответы, которые Пролог только может найти:

    ?- список_длинна(Ls, L).

    Ls = [], L = 0 ;
    Ls = [_2130], L = 1 ;
    Ls = [_2130, _2668], L = 2 ;
    etc.

В этом случае мы говорим что отношение может быть !!использовано в различных направлениях!!. Что характерно, Пролог находит все ответы с помощью механизма отката.

Предикат `length/2`, аналогичный нашему предикату `список_длинна/2`, является частью проекта [Prologue for Prolog](https://www.complang.tuwien.ac.at/ulrich/iso-prolog/prologue), и доступен как сиситемный предикат в почти всех имплементациях Пролога.

## Пролог --- логический язык

Декларативные языки делятся на два класса --- функциональных и логических языков программирования. Функция --- это особенная форма отношения, и следовательно можно рассматривать функциональные языки как ограниченную версию языков логических. Программы на чистом прологе состоят из множества [хорновых предложений](https://ru.wikipedia.org/wiki/%D0%A5%D0%BE%D1%80%D0%BD%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9_%D0%B4%D0%B8%D0%B7%D1%8A%D1%8E%D0%BD%D0%BA%D1%82). Выполнение программ на Прологе является способом логического вывода, а сам алгоритм вывода базируется на формальной логике. Логически, когда Пролог ищет ответ на вопрос, он пытается найти опровержение _отрицания запроса_ и _утверждений программы_. Если опровержение найдено, то запрос является логическим следствием утверждений приведённых в программе.

Такая связь с формальной логикой позволяет нам применять мощные средства декларативной отладки, базирующихся на логических свойствах программы. Например, добавление ограничения к программе не может увеличить количество решений, а добавление новых утверждений не может уменьшить количество решений. Это свойство программ на _чистом Прологе_ называется !!монотонностью!!

Программа [GUPU](https://www.complang.tuwien.ac.at/ulrich/gupu/), разработанная Ульрихом Ноймеркелем представляет собой впечатляющее применение этих идей.

## Пролог — гомоиконный язык

> от греч. ὁμός — «равный», «одинаковый» и εἰκόνα — «о́браз», «изображение»

Программы на Прологе сами являются термами! Это является большим преимуществом Пролога перед многими другими языками --- можно с лёгкостью писать программы которые анализируют, преобразуют и интерпретируют другие программы. Для чтения термов, а следовательно и утверждений, можно использовать встроенный предикат `read/1`.

В Пролог встроен мощный механизм преобразования программ во время компиляции, что позволяет определять собственный предметно-ориентированные язык, который помогает более естественным образом отразить специфику решаемых с его помощью задач.

В это, возможно, сложно поверть, потому что одни цели --- такик как `список_длинна(Ls, N)` --- выглядят как обычные термы, а другие --- такие как `N #> 0` --- совсем по-другому. Причиной этому является возможность определять префиксные, инфиксные и постфиксные операторы, которые позволяют записывать утверждения в более естественном виде. Например, терм `+(a, b)` также может быть записан и в инфиксной форме `a + b`.  При всём этом абстрактный синтакс Пролога остаётся совершенно униформным, и автоматической чтение и обработка термов на Прологе не зависит от формы записи.

Программы могут определять новые операторы для собственных нужд.

## Пролог --- динамический язык

Программы на Прологе могут быть легко созданы, выполненны и изменены во время выполнения. Это ещё больше повышает выразительность языка и позволяет реализовать предикаты высшего порядка, принимающие в качестве аргументов другие предикаты. Это также позволяет реализовать очень динамичные алгоритмы, такие как адаптивный синтаксический анализ. Динамический характер Пролога делает язык идеально подходящим для написания программ, расширяемым по специальным правилам, предоставляемым другими программистами и даже обычными пользователями. [Proloxy](https://www.metalevel.at/proloxy/) и [Gerrit Code Review](https://www.gerritcodereview.com/) являются примерами такого подхода: для настройки этих программы используются правила записаные в форме утверждений на Прологе и выражающие требования пользователя очевидным и гибким способом. Дополнительная информация приведена в главе «[Мета-интерпретаторы]()».

> Интерпретатор для чистого Пролога состои из двух строках кода.

## Пролог --- разносторонний язык

Пролог --- исключительно разносторонний язык. Реляционная природа языка делает его гибким и универсальным и играет важную роль в задачах обработки естественного языка и представления знаний. Современный Пролог предоставляет всё необходимое для решения самых разнообразных задач, от логических головоломок, до построения масштабных приложений, от разработки интернет сайтов, до верификации и оптимизации.