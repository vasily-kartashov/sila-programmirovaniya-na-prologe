# Основные понятия

В этой главе мы введём и определим самые основные концепции Пролога.

## Термы

В Прологе все данные, включая сами программы на Прологе, представлены термами. Программы могут определять дополнительные префиксные, инфиксные и постфиксные операторы, с помощью которых можно вводить новые термы. Некоторые операторы встроены в Пролог. Например, вы можете написать `a + b` и `X = Y` вместо `+(a, b)` и `=(X, Y)`.

## Программы

Программы на Прологе представляет собой множество предикатов. Каждый предикат описывает отношения между его аргументами. С точки зрения логики, программа на Прологе описывает то, что имеет место быть. Существуют определённые устоявшиеся конвенции, как следует писать программы на Прологе, и несколько подходов к их прочтению.

## Предикаты

У каждого предиката есть имя, и ноль или несколько аргументов. Имя предиката является атомом. Аргументы предиката являются произвольными термами. Предикат `предикат` с `n` аргументами обозначается `предикат/n`, такая форма записи называется предикатный индикатор (predicate indicator). `n` называется !!арностью!! предиката.

Определение предиката состоит из одного или нескольких утверждений. Утверждения в свою очередь бывают двух видов: правила и факты. Различные утверждения в составе предиката представляют собой логический альтернативы: если одно из утверждений верно, то верен и весь предикат.

## Правила

Правила в Прологе имеют слудущую форму:

    Голова :- Тело.

Форма записи головы правила зависит от количества аргументов:

- Если у предиката нет аргументов, то голова правила состоит просто из имени предиката.
- Если у предиката `предикат` есть положительное число аргументов `n`, тогда голова правила записывается в форме: `предикат(Аргумент_1, Аргумент_2, ... Аргумент_n)`.

Тело каждого правила является целью. Цель --- это терм который содержащий выражение и для предиката и для его аргументов. Правило называется рекурсивным, если одна из его целей ссылается на сам предикат, который определяется этим правилом.

## Факты

Факт записывается как:

    Голова.

Этот факт эквивалентен следующему правилу:

    Голова :- true.

Это запись означает, что логически это правило верно всегда, потому что встроенный предикат `true/0` всегда верен.

## Командная оболочка

Командная оболочка --- основной способ запуска програм на Прологе. Для вызова предиката мы задаём вопрос, который есть произвольная цель. Логический переменные в вопросе интерпертируются экзистенциально, т. е. вопрос с переменными слудует читать как: "Существуют ли значения переменных, при которых данный предикат верен?"

Если цель достигнута, оболочка выводит ответ на экран. Ответом является цель, которая декларативно эквивалентна вопросу. Для каждого предиката можно сформулировать !!наиболее общий вопрос!!, который представляет собой цель, где _все_ аргументы --- переменные.

Обратите внимание, что некоторые цели могут быть достигнуты более чем одним способом. В зависимости от реализации Пролога, для вывода альтернативных решений нужно нажимать либо пробел, либо «;».

## Исполнение кода на Прологе

Запуск программы на Прологе можно рассматривать как частный случай логического вывода, который является алгоритмом, коренящимся в формальной логике. С точки зрения логики, при поиске ответа на вопрос (Q), ищется опровержение коньюнкции (/\) отрицания вапроса (not Q) и набора предложений (A1, A2, ... An), составляющих программу. Когда опровержение найдено, это означает, что запрос является логическим следствием программы.

Важным шагом в этом процессе является синтаксическая унификация терминов. Унификация --- это процесс сопоставления с образцом.
После выбора головы правила для унификации с целью, рекурсивно происходит унификация аргументов. Именно по этой причине в чистых предикатах нет разницы между аргументами ввода и вывода, и такие предикаты могут быть использованы во всех направлениях.

Если несколько утверждений унифицируются с целью, тогда такие альтернативы перебираются с помощью механизма возврата. Неформально такая стратегия поиска, называемая [поиском в глубину](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83) с хронологическим возвратом, может быть сравнена с вызовом методов в императивных языках программирования. Основные отличия заключаются в следующем: (1) множественные предложения могут совпадать и (2) унификация работает в обоих направлениях.

При поиске ошибок в программах на Прологе обычно нет необходимости в пошаговом исполнении. Заместо этого, можно воспользоваться методом декларативной отладки для поиска логичских ошибок.

## Встроенные предикаты

Некоторые предикаты доступны сразу после запуска и не требуют дополнительного определения. Эти предикаты называются встроенными или системными. Например, системный предикат `(=)/2` верен тогда и только тогда когда аргументы унифицируемы. Встроенный предикат `true/0` всегда верен, а встроенный предикат `false/0` всегда ложен.

Многие встроенные предикаты существуют исключительно для удобства, и при необходимости вы могли бы ввести их самостоятельно. Например, если бы вышеназванные предикаты не были бы встроены, вы могли бы определить их следующим способом:

    T = T.
    true.
    false :- a = b.

Однако не все встроенные предикаты могут быть определены подобным образом. Помимо `(=)/2`, `true/0` и `false/0`, при написании полезных и чистых программ на Прологе самими полезными для вас будут следующие встроенные предикаты:

- `dif/2` верен тогда и только тогда, когда аргументы этого предиката отличаются друг от друга
- Целочисленные ограничения позволяют выражать логические отношения между арифметическими выражениями
- `(',')/2` означает конъюнкцию: `(A, B)` верны тогда и только тогда, когда верны и `A` и `B`
- `(';')/2` означает дизъюнкцию: `(A; B)` верны тогда и только тогда, когда верны либо `A`, либо `B`, либо оба.

## Пример: гипотеза Коллатца

Проиллюстрируем введённые в этой главе понятия примером. Рассмотрим следующую последовательность.

Возьмём произвольное положительное число _N_. Чтобы вычислить следующее за ним число, надо:
- Если _N_ --- чётно, разделить его на пополам, т. е. _N / 2_,
- Если _N_ --- нечётно, умножить его на 3 и прибавить 1, т.е. _3 × N + 1_.
Таким образом можно вычислить произвольное количество членов последовательности _N0_, _N1_, _N2_ ...

Гипотеза Коллатца заключается в том, что какое бы начальное число _N0_ мы ни взяли, рано или поздно один из членов последовательности будет равен единице.

Эту последовательность можно смоделлировать используя встроенное целочисленное ограничение `(#=)/2` для обозначения равенства двух выражений:

    hailstone(N, N).
    hailstone(N0, N) :-
            N0 mod 2 #= 0,
            N1 #= N0 // 2,
            hailstone(N1, N).
    hailstone(N0, N) :-
            N0 mod 2 #= 1,
            N1 #= 3 * N0 + 1,
            hailstone(N1, N).

Предикат `hailstone/2` содержит три утверждения: один факт и два правила. Он определяет отношение между двумя аргументами. Первый аргумент представляет текущий член последовательности. Второй аргумент используется для вывода решения на экран. После отправки запроса командной оболочке выводится ответ, альтернативные решения перебираются с помощью с механизма отката:

    ?- hailstone(3, N).
    N = 3 ;
    N = 10 ;
    N = 5 ;
    N = 16 ;
    N = 8 ;
    N = 4 ;
    N = 2 ;
    N = 1 ;
    N = 4 ;
    N = 2 ;
    N = 1 .


Эта программа иллюстрирует способ моделлирования _последовательности действий_ через _отношение между последовательными состояниями_. В главе «[]()» будет рассмотрены допольнительные примеры такого способа моделлирования. Как верно для всех чистых отношений, предикат `hailstone/2` можно использовать во всех направлениях. Например, отправив наиболее общий запрос:

    ?- hailstone(X, Y).
    X = Y ;
    X//2#=Y,
    X mod 2#=0 ;
    X//2#=_1824,
    X mod 2#=0,
    _1824//2#=Y,
    _1824 mod 2#=0 ;
    X//2#=_2254,
    X mod 2#=0,
    _2254//2#=_2302,
    _2254 mod 2#=0,
    _2302//2#=Y,
    _2302 mod 2#=0 .

Изучая предикат Prolog, попробуйте самый общий запрос, чтобы посмотреть, как выглядят ответы _в общем_.

Возможна более эффективная реализация предиката `hailstone/2` в помощью [`if_/3`]().