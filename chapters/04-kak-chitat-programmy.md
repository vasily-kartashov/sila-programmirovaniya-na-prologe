
# Как читать программы на Прологе #

Возможно написать программу на Прологе за один присест, и даже если вы перепишете её после этого пару раз, прочитана она будет вами и другими разработчиками несравненно большее количество раз. Следовательно, важно знать, как же лучше всего читать программы на Прологе, как понять, что именно они значат?

Существует несколько способов прочтения чистых программ на Прологе, и мы объясняем некоторые из них в этой главе.

## Декларативное прочтение ##

С декларативной точки зрения, программы на языке Пролог описывают то, что истинно. Программы на Прологе состоят из утверждений, и каждое утверждение является либо фактом, либо правилом. Факты выражают то, что истинно всегда. Правила выражают то, что истинно при выполнении определённых условий.

Декларативно правило `Голова :- Тело`. читается как: «Если `Тело` верно, то и `Голова` тоже верна». В терминах математической логики это же правило читается как «Из `Тело` следует `Голова`», и записывается как `Тело -> Голова` или `Голова <- Тело`. Интересно заметить, что знак `:-` на самом деле был выбран как намёк на стрелку `<-`. Поскольку `Тело` определяет условия, при которых выполняется `Голова`, утверждения приведённые в `Тело` можно рассматривать как набор ограничений. Такой способ прочтения программ на Прологе также называется !!заключительным чтением!! (concluding reading).

Основным преимуществом такого подхода является то, что его легко объяснить, понять и использовать. Необходимо лишь указать, какие отношения верны и при каких условиях, и Пролог попытается найти решение. Недостатком такого подхода является то, что он не объясняет, почему логически эквивалентные варианты программы могут демонстрировать разные характеристики производительности или терминирования.

### Пример ###

Рассмотрим предикат `список_список_объединение/3`, описывающий объединение двух списков:

    список_список_объединение([], Bs, Bs).
    список_список_объединение([A|As], Bs, [A|Cs]) :-
            список_список_объединение(As, Bs, Cs).

Давайте прочитаем это определение декларативно, то есть в терминах отношений между аргументами, точно так, как записано в двух утверждениях этого предиката:

- Объединение пустого списка `[]` и любого другого списка `Bs` равно тому же самому списку `Bs`.
- Если объединение `As` и `Bs` равно `Cs`, то объединение `[A|As]` и `Bs` равно `[A|Cs]` для любого `A`.

Заметьте насколько универсально такое прочтение: оно верно для всех случаев использования, независимо от связанности аргументов.

## Процедуральное прочтение ##

В дополнение к декларативному подходу к прочтению программ на Прологе, также возможно процедурное их прочтение. Такое прочтение означает, что мы учитываем фактическую _вычислительную стратегию_ Пролога. С операционной точки зрения, использование предиката  аналогично вызову процедуры или функции на других языках. Однако остаются два критических отличия: во-первых, переменные в Прологе являются логическими переменными. Во-вторых, Пролог использует механизм отката, и следовательно перебирает все альтернативные формы вызова.

По этим причинам процедурная интерпретация программы на Прологе значительно сложнее, чем понимание потока управления во многих других языках программирования. В частности, при пошаговом исполнении программ на Прологе необходимо учитывать:

- _связанность_ пременных,
- _переименования_ переменных,
- _альтернативы_, найденые механизмом отката.

Необходимость отслеживать эти факторы и взаимодействие между ними является основным недостатком такого подхода. Преимуществом подхода является его способность объяснить различные характеристики производительности и завершаемости различных вариантов одной  той же логической программы.

Отметим также, что процедуральное прочтение почти всегда подразумевает конкретное направление использования предиката и, следовательно, не в состоянии полностью раскрыть универсальность логического отношения выраженного  предикатом.

### Пример ###

Рассмотрим процедурное прочтение предиката `список_список_объединение/3`, приведённого выше, для вопроса `?- список_список_объединение([x,y], [z], Cs)`.

- Применимо ли первое правило? Нет, потому что список `[x,y]` не унифицируем с `[]`.
- Применимо ли второе правило? Заметим, что алгоритм вывода требует ввода новых переменных при переборе утверждений. Итак, введём переменные `A'`, `As'`, `Bs'`, и `Cs'` чтобы использовать их вместо переменных `A`, `As`, `Bs` и `Cs` из головы утверждения. Ответ утвердительный, второе правило применимо с подстановкой `A' = x`, `As' = [y]`, `Bs' = [z]`, `Cs = [A'|Cs']`. Наш вывод уже довольно громоздок и подвержен ошибкам, и по мере дальнейшего продвижения отслеживать все привязки переменных будет всё сложнее и сложнее.
- Продолжая, рассмотрим цель `список_список_объединение([y], [z], Cs')`, повторим всё те же вопросы, что и раньше, только теперь для новой цели.
- Применимо ли первое правило? Нет, потому что список `[y]` не унифицируем с `[]`.
- Применимо ли второе правило? Нам опять придётся переименовать переменные. Возьмём в этот раз `A''`, `As''`, `Bs''` and `Cs''`. Да, это правило применимо с подстановкой `A'' = y`, `As'' = []`, `Bs'' = [z]` and `Cs' = `[A''|Cs'']`.
- И ещё раз повторим наше суровое испытание, на этот раз рассмотрев цель `список_список_объединение([], [z], Cs'')`.
- Применимо ли первое правило? Да, наконец-то! Заметим, что нам, конечно, снова придётся ввести свежие пременные. Пусть `Bs'''` соответствует единсвенной переменной из головы первого правила. Первое правило применимо с подстановкой `Bs''' = [z]` и `Cs'' = Bs'''`. Это значит, что по крайней мере одно решение найдено, и выражено в виде привязки значения к переменной `Cs''`, единственной оригинальной переменной в вопросе. Если вы тщательно следили за всеми перепетиями этой трассировки (я уверен, что вы не моглу пропустить такой удовольствие), то вам, конечно, известно что `Cs` было унифицированно с `[A'|Cs']`. А так как `A'` в свою очередь было унифицированно с `x`, а `Cs'` --- с `[A''|Cs'']`, и далее `A''` --- с `y`, то это значит, что `Cs` --- это тоже самое, что и `[x,y|Cs'']`. И как мы только что заметили, `Cs''` было унифицированно с `Bs'''`, а `Bs'''` --- с `[z]`. Следовательно, решение найдено --- `Cs = [x,y,z]`, и это решение передано на верхний уровень коммандной оболочке.
- Кстати, нам всё ещё нужно рассмотреть второе правило: нет, оно не применимо, потому что `[]` не унифицируется с `[_|_]`.

Это только для одного конкретного случая! Аккуратный разбор всех возможных процедуральных прочтений одного предиката исключительно сложен и обычно требует подробного объяснения. В большинстве случае осуществить это совершенно невозможно в силу большого количества вариантов подлежащих рассмотрению.

## Програмное рассечение (Program slicing) ##

Рассечение --- это простой и мощный метод, который использует самые общие свойства чистого Пролога для изучения эффектов обобщения и специализации программы.

Примерами таких общих свойств являются:

- удаление цели может сделать программу более общей, но никак не более конкретной,
- удаление предложения может сделать программу более конкретной, но никогда более общей,
- вставка `false/0` между любыми двумя целями в правиле позволяет игнорировать процедурные эффекты всех целей после точки вставки.

Если быть совершенно точным, вырезка нужна для локализации причины наблюдаемого поведения программы.

Проиллюстрируем это на простом примере. Рассмотрим следующую версию предиката `список_длина/2`, связывающего список с его длиной:

    список_длина([_|Ls], N) :-
        список_длина(Ls, N0),
        N #> 0,
        N #= N0 + 1.
    список_длина([], 0).

Предикат работает как надо, если первый аргумент связан. Например:

    ?- list_length([], L).
    L = 0.

    ?- list_length([_,_,_], L).
    L = 3.

Однако предикат не выдаёт ни одного ответа на самый общий вопрос:

    ?- list_length(Ls, L).

Рассечение промогает нам увидеть причину. Программный код следующий за целью `false` не нужен для понимания поведения, которое мы наблюдаем:

    list_length([_|Ls], N) :-
        list_length(Ls, N0),
        false,
        N #> 0,
        N #= N0 + 1.

    list_length([], 0) :-
        false.

Осташаяся часть ответственна за непрерывающееся вычисление. Какие бы изменения мы не внесли в часть кода после цели `false`, нашей проблемы это не решит.

Программные вырезки могут быть сгенерированы автоматически и являются мощным способом поиска причин нетерминирования и других нежелательных качеств программ на Прологе. Примеры приведены в (Stefan Kral et al., Slicing zur Fehlersuche in Logikprogrammen, WLP 2000).
