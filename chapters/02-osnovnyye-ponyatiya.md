
# Основные понятия #

В этой главе мы введём и определим самые основные понятия используемые в Прологе.

## Термы ##

Все данные в Прологе, включая сами программы, являются термами. Программы могут определять дополнительные префиксные, инфиксные и постфиксные операторы, с помощью которых можно вводить новые термы. Некоторые операторы встроены в Пролог. Например, можно писать `a + b` и `X = Y` вместо `+(a, b)` и `=(X, Y)`.

## Программы ##

Программы на Прологе представляют собой набор предикатов. Каждый предикат описывает отношения между своими аргументами. С точки зрения логики, программа на Прологе описывает _то, что истинно_. Существуют определённые устоявшиеся конвенции, как следует писать программы на Прологе, и несколько подходов к их прочтению.

## Предикаты ##

У каждого предиката есть имя, и, возможно, несколько аргументов. Имя предиката является атомом. Аргументы предиката являются произвольными термами. Предикат `предикат` с `n` аргументами обозначается `предикат/n`, такая форма записи называется предикатный индикатор (predicate indicator). `n` называется *арностью* предиката.

Определение предиката состоит из одного или нескольких утверждений. Утверждения в свою очередь бывают двух видов: правила и факты. Различные утверждения в составе предиката представляют собой логические альтернативы: если одно из утверждений верно, то верен и весь предикат.

## Правила ##

Правила в Прологе записываются в слудующем виде:

    Голова :- Тело.

Форма записи головы правила зависит от количества аргументов:

- Если у предиката нет аргументов, то голова правила состоит просто из имени предиката.
- Если у предиката `предикат` есть положительное число аргументов `n`, тогда голова правила записывается в форме: `предикат(Аргумент_1, Аргумент_2, ... Аргумент_n)`.

Тело каждого правила является целью. Цель --- это терм, содержащий выражение и для предиката и для его аргументов. Правило называется *рекурсивным*, если одна из его целей ссылается на сам предикат, который определяется этим правилом.

## Факты ##

Факт записывается как:

    Голова.

Этот факт эквивалентен следующему правилу:

    Голова :- true.

Такая запись означает, что правило верно всегда, потому что встроенный предикат `true/0` всегда верен.

## Командная оболочка ##

Командная оболочка --- основной способ запуска програм на Прологе. Для вызова предиката мы задаём вопрос, который есть произвольная цель. Логический переменные в вопросе интерпертируются экзистенциально, т. е. вопрос с переменными слудует читать как: "_Существуют_ ли значения переменных, при которых данный предикат верен?"

Если цель достигнута, оболочка выводит ответ на экран. Ответом является цель, которая декларативно эквивалентна вопросу. Для каждого предиката можно сформулировать !!наиболее общий вопрос!!, который представляет собой цель, где _все_ аргументы --- переменные.

Обратите внимание, что некоторые цели могут быть достигнуты более чем одним способом. В зависимости от реализации Пролога, для перебора решений нужно нажимать либо пробел, либо «;».

## Исполнение кода на Прологе ##

Запуск программы на Прологе можно рассматривать как частный случай логического вывода, который является алгоритмом, коренящимся в формальной логике. С точки зрения логики, при поиске ответа на вопрос (_Q_), ищется опровержение коньюнкции (/\) отрицания вапроса (_not Q_) и набора предложений (_A1_, _A2_, ... _An_), составляющих программу. Если опровержение найдено, то это означает, что вопрос является логическим следствием программы.

Важным шагом в этом процессе является синтаксическая !!унификация!! терминов. Унификация --- это процесс сопоставления с образцом. После выбора головы правила для унификации с целью, происходит рекурсивная унификация всех аргументов. Именно по этой причине в чистых предикатах нет разницы между аргументами ввода и вывода, и такие предикаты могут быть использованы во всех направлениях.

Если несколько утверждений унифицируются с целью, тогда такие альтернативы перебираются с помощью механизма возврата. Неформально такая стратегия поиска, называемая [поиском в глубину](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83) с хронологическим возвратом, может быть сравнена с вызовом методов в императивных языках программирования. Основные отличия заключаются в следующем: (1) множественные предложения могут совпадать и (2) унификация работает в обоих направлениях.

При поиске ошибок в программах на Прологе обычно нет необходимости в пошаговом исполнении. Вместо этого, можно воспользоваться методом декларативной отладки для поиска логичских ошибок.

## Встроенные предикаты ##

Некоторые предикаты доступны сразу после запуска и не требуют дополнительного определения. Эти предикаты называются встроенными или системными. Например, системный предикат `(=)/2` верен тогда и только тогда когда аргументы унифицируемы. Встроенный предикат `true/0` всегда верен, а встроенный предикат `false/0` всегда ложен.

Многие встроенные предикаты существуют исключительно для удобства, и при необходимости могут быть определены в программе. Например, возможно определить вышеупомянутые предикаты следующим способом:

    T = T.
    true.
    false :- a = b.

Заметим, что не все встроенные предикаты могут быть определены подобным образом. Помимо `(=)/2`, `true/0` и `false/0`, при написании полезных и чистых программ на Прологе самими полезными являются следующие встроенные предикаты:

- `dif/2` верен тогда и только тогда, когда аргументы этого предиката отличаются друг от друга
- Целочисленные ограничения позволяют выражать логические отношения между арифметическими выражениями
- `(',')/2` означает конъюнкцию: `(A, B)` верны тогда и только тогда, когда верны и `A` и `B`
- `(';')/2` означает дизъюнкцию: `(A; B)` верны тогда и только тогда, когда верны либо `A`, либо `B`, либо оба.

## Пример: гипотеза Коллатца ##

Проиллюстрируем введённые в этой главе понятия примером. Рассмотрим следующую последовательность.

Возьмём произвольное положительное число _N_. Чтобы вычислить следующее за ним число, надо:
- Если _N_ --- чётно, разделить его на пополам, т. е. _N / 2_,
- Если _N_ --- нечётно, умножить его на _3_ и прибавить _1_, т.е. _3 × N + 1_.
Таким образом можно вычислить произвольное количество членов последовательности _N0_, _N1_, _N2_ ...

Гипотеза Коллатца заключается в том, что какое бы начальное число _N0_ мы ни взяли, рано или поздно мы встретим один из членов последовательности равный единице.

Эту последовательность можно смоделлировать используя встроенное целочисленное ограничение `(#=)/2` для обозначения равенства двух выражений:

    hailstone(N, N).
    hailstone(N0, N) :-
            N0 mod 2 #= 0,
            N1 #= N0 // 2,
            hailstone(N1, N).
    hailstone(N0, N) :-
            N0 mod 2 #= 1,
            N1 #= 3 * N0 + 1,
            hailstone(N1, N).

Предикат `hailstone/2` содержит три утверждения: один факт и два правила. Он определяет отношение между двумя аргументами. Первый аргумент представляет текущий член последовательности. Второй аргумент используется для вывода решения на экран. После отправки запроса командной оболочке выводится ответ, альтернативные решения перебираются с помощью с механизма отката:

    ?- hailstone(3, N).
    N = 3 ;
    N = 10 ;
    N = 5 ;
    N = 16 ;
    N = 8 ;
    N = 4 ;
    N = 2 ;
    N = 1 ;
    N = 4 ;
    N = 2 ;
    N = 1 .


Эта программа иллюстрирует способ моделлирования _последовательности действий_ через _отношение между последовательными состояниями_. В главе «[]()» будет рассмотрены допольнительные примеры такого способа моделлирования. Как верно для всех чистых отношений, предикат `hailstone/2` можно использовать во всех направлениях. Например, отправив наиболее общий запрос:

    ?- hailstone(X, Y).
    X = Y ;
    X//2#=Y,
    X mod 2#=0 ;
    X//2#=_1824,
    X mod 2#=0,
    _1824//2#=Y,
    _1824 mod 2#=0 ;
    X//2#=_2254,
    X mod 2#=0,
    _2254//2#=_2302,
    _2254 mod 2#=0,
    _2302//2#=Y,
    _2302 mod 2#=0 .

Исследуя свойства предикатов, пробуйте самый общий запрос, чтобы увидеть, как выглядят ответы _в общем_.

Заметим, что возможна и более эффективная реализация предиката `hailstone/2` через использование [`if_/3`]().