
# Структуры данных #

## Термы ##

Все данные в Прологе представлены в виде термов. Сами термы определены индуктивно:

- _атом_ является термом. Примерами атомов являются: `x`, `test` и `'quotes and space'`.
- _переменная_ является термом. Имя переменной начинается либо с заглавной буквы, либо со знака подчёркивания `_`. Одинокий знак подчёркивания означает анонимную переменную и произносится как "любой терм".
- _целые числа_ и _числа с плавающей точкой_ являются термами. Примеры: `42` и `42.42`.
- _составным_ назвается терм, определённый индуктивно следующим образом: если `T1`, `T2`, ... `Tn` --- термы, то и `f(T1, T2, ... Tn)` тоже терм, `f` называется функтором составного терма, а `n` называется его арностью. Примеры: `f(a)`, `g(f(X))` and `+(a, f(X))`.

В подобном виде могут быть представлены любые данные. Термам не требуется отдельного определения и они вводятся в текст программы через своё использование. Пролог динамически типизированный язык и обладает исключительной гибкостью при выборе представления для данных. Например, возможно слудующее представление для натуральных чисел:

- атом `zero` будет представлять число 0
- составной терм `s(X)` терм будет представлять число следующее за `X`.

При такой записи, число 3 будет представлено термом `s(s(s(zero)))`. Конечно такая форма записи совершенно непрактична хотя бы из-за размеров термов, необходимых для представления больших чисел. Поэтому Пролог предоставляет встроенные и более эффективные средства для работы с целочисленной арифметикой.

Термы в Прологе могут быть естественным образом представлены в виде деревьев. Для сортировки термов существует [стандарный порядок]().

## Списки ##

Списки в Прологе являются термами. Списки определены индуктивно:

- атом `[]` является списком и означает пустой список
- если `Ls` --- список, то и терм `.(L,Ls)` тоже является списком.

Для удобства в Прологе существует специальное написание для списков:

- Список `.(a,.(b,.(c,[])))` может быть записан как `[a,b,c]`.
- А терм `.(L,Ls)` может быть записан как `[L|Ls]`.

Вышеприведённые формы записи можно произвольно комбинировать. К примеру, терм `[a,b|Ls]` является списком тогда и только тогда, когда `Ls` является списком.

Списки естественно использовать для представления коллекций элементов, и по этой причине списки можно встретить практически в каждой программе на Прологе. Следующие вопросы помогут выбрать тип данных для представления коллекции элементов:

- Неограничено ли число элементов в коллекции?
- Допустима ли пустая коллекция?
- Важен ли порядок элементов в коллекции?
- Одного ли типа элементы в коллекции?

Если вы ответили утвердительно на большинство из этих вопросов, то список это скорее всего то, что вам нужно.

Для контраста рассмотрим пример коллекций состоящих из ровно трёх элементов. Мы могли бы записать их в виде списка `[A,B,C]`, что позволило бы нам, например, применять мета-предикаты при определении дополнительных требований, предъявляемых к структуре и содержанию этих коллекций. С другой стороны запись с помощью составного терма вида `f(A,B,C)` требует меньше памяти, потому что список `[A,B,C]` есть ничего иное как составной терм вида `.(A,.(B,.(C,[])))` и он займёт в памяти места почти вдвое больше, чем `f(A,B,C)`.

Для описания структуры списков часто используется [грамматики определяющих предложений]().

## Пары ##

По сложившейся традиции, функтор `(-)/2` часто используется в Прологе для обозначения пары объектов. Например, терм `-(A, B)` означает пару элементов `A` и `B`. Функтор `(-)/2` определён как инфиксный оператор, а следовательно упомянутый терм также может быть записан в инфиксной форме `A-B`.

Многие распространённые предикаты, такие как `keysort/2` и `pairs_keys_values/3`, используют этот синтакс для обозначения пар.

## Ассоциативные списки ##

Многие реализации Пролога предоставляют ассоциативные списки для быстрого, линейного доступа к элементам коллекции. Обычно реализация таких типов данных базируется на сбалансированных деревьях, таких как АВЛ-деревья. Общедоступна библиотека library(assoc), которая поставляется со многими системами Prolog и предоставляет операции для вставки, выборки и изменения элементов коллекции.

Приведём один из способов представить АВЛ-дерево на Прологе:

- Пустое дерево обозначим атомом `t`.
- Внутренние узлы будут представлены составным термом `t(Key, Value, Balance, Left, Right)` где:
  - `Key` и `Value` представляет _связь_ между ключом `Key` и значением `Value`.
  - `Balance` --- атом описывающий критерий балансировки, такой как отношение между количеством детей на левом и правом поддеревьях. Например, мы можем использовать атомы <, = и > чтобы обозначить различные отношения между поддеревьями.
  - `Left` и `Right` являются левым и правым АВЛ-поддеревьями подвешенными к данному узлу.

Каждая операция над АВЛ-деревом, такая как, например, добавление вершины, может быть представлена как отношение между двумя различными деревьями --- первое дерево представляющее состояние до операции, а второе дерево --- состояние после операции. Дополнительная информация приведена в главе "[Thinking in States]()". Большинство важных операций над АВЛ-деревьями выполняются за время _&Oscr;(log(N))_, где _N_ количество связей в дереве. Для многих случаев это достаточно быстро.

## Строки ##

Почти все, что следовало сказать о строках, было уже замечательно сказано Ричардом О'Кифом в его предложении по стандартной библиотеке языка Пролог. А именно, строки плохи, и

> Для почти любого случая обработки данных, единственное разумное отношение к строкам --- поскорее преобразовать их в какое-нибудь дерево. Пролог великолепен при работе с деревьями.

Удобно представлять строки как списки, состоящие из отдельных литер, которые как известно являются атомами. Для использования такого представления строк в вашей программе, необходимо добавить в программу активирующую эту опцию директиву:

    :- set_prolog_flag(double_quotes,chars).

После выбора этой опции, мы увидим, например:

    ?- Cs = "test".
    Cs = [t,e,s,t].

Таким образом работа со строками не отличается от работы со списками, а с последними на Прологе работать легко.

## Массивы ##

Как насчёт массивов? Есть ли в Прологе структура данных для представления коллекций термов, с константным временем доступа _&Oscr;(1)_ к отдельным элементам по индексу?

Прежде всего, сама идея изменения состояния объекта, т. е. разрушительной модификации, чужда логическому программированию. Программы на Прологе содержат описание отношений между объектами, а не последовательность операций по изменению состояния этих объектов. Для выражения изменения состояния какой-либо структуры данных, мы определяем предикат связывающий вместе два состояния --- до и после модификации. По этой причине чистые модификации часто влекут за собой некоторое копирование данных и, как правило, приводят к по меньшей мере логарифмическим издержкам (например, для копирования поддерева сбалансированного дерева).

При этом возможно получить доступ к аргументам терма в O(1) используя системный предикат `arg/3`. Также есть нечистый предикат, называемый `setarg/3`, который допускает деструктивные модификации терма. Используйте его на свой страх и риск: используя `setarg/3`, вы больше не cможете рассуждать о своем коде так, как это было возможным в чистом Прологе. Если вам действительно нужны эффективные деструктивные модификации термов, рекоммендуется использовать атрибутивные переменные.

## Чистое и defaulty представление ##

При выборе структуры данных на Прологе, задайтесь следующим вопросом:

_Возможно ли распознать тип элемента структуры данных через имя внешнего функтора и его арность?_

Если ответ утвердительный, то такое представление называется !!чистым!!. В противном случае, представление называется defaulty (умолчащим), от игры слов "default" --- по умолчанию, и "faulty" --- поломаный. Такое название выбрано, потому что при работе с defaulty данными всегда требуется явная обработка «случая по умолчанию», который будет выбран когда все остальные условия не выполняются. Кроме того, такое представление препятствует индексации аргументов и считается ошибочным из-за этого недостатка. Всегда прилагайте усилия, для избежания таких defaulty представлений, и пытайтесь найти чистую форму представления для ваших данных.

Например, рассмотрим представление полного двоичного дерева на Прологе. Такие деревья состоят из элементов двух типов:

- _лист_, содержащий конкретное значение,
- _узел_, имеющий двух детей, которые в свою очередь являются полными двоичными деревьями.

Мы можем использовать следующую форму представления дерева с помощью термов:

- `лист(Лист)` означает лист `Лист`,
- `узел(ЛевоеПоддерево, ПравоеПоддерево)` означает узел и два поддерева исходящих из него.

Такое представление чисто: мы можем определить тип элемента (узел или лист) через внешний функтор. Рассуждения относительно таких деревьев могут быть записаны в самой общей форме и использованы во всех направлениях. Такое представление также не мешает индексированию аргументов.

Вы также можете распознать чистое представление, если оно позволяет описать общую структуру ваших данных, сохраняя при этом достаточную гибкость, чтобы сохранить конкретные элементы неопределенными. Например, в случае полных двочных деревьев мы можем представить общую форму всех деревьев с ровно двумя листьями как `узел(лист(_), лист(_))`. Если же искючить из представления данных обёртку `лист/1`, то мы получим `узел(_, _)` --- форму, которая не в состоянии отличить деревья с ровно двумя листьями от всех остальных деревьев.

Иногда может показаться что чистого решения для проблемы не существует. Мы можем столкнуться с таким представлением данных, при котором необходимо использование нечистых и немонотонных предикатов для идентификации различных способов использования предиката; например таких как `var/1`, проверяющих свободна ли переменная. В таком случае рекомендуется ограничивать нечистые части вашей программы небольшими участками и преобразовывать любое defaulty представление в чистое, вводя подходящие обёртки, которые помогут различать чистое использование от нечистого через обычное сопоставление с образцом. При таком подходе использование основных предикатов возможно в разных направлениях.

## Инспектирование термов ##

Самым естественным способом исследовать предикаты является использование унификации. В дополнение к этому способу в Прологе есть несколько предикатов помогающих при инспектировании термов. Самыми важными для инспектирования термов предикатами являются `functor/3`, `arg/3` и `(=..)/2`.

Вот несколько примеров использования:

    ?- functor(f(a, g(X)), Функтор, Арность).
    Функтор = f,
    Арность = 2.

    ?- functor(Терм, f, 2).
    Терм = f(_25002, _25004).

    ?- arg(2, f(a, g(X)), Аргумент).
    Аргумент = g(X).

    ?- f(a,g(X)) =.. [Функтор|Аргументы].
    Функтор = f,
    Аргументы = [a, g(X)].

    ?- Терм =.. [f, a, g(X)].
    Терм = f(a, g(X)).

Эти предикаты невозможно выразить через конечный набор утверждений, и по этой причине они могут отнесены к предикатам высшего уровня. Однако не стоит злоупотреблять ими! Всё что можно выразить с помощью сопоставления с образцом, должно быть выражено таким образом. Например, вместо `functor(Term, f, 2)`, можно просто использовать `writeTerm = f(_, _)`.

У каждого терма в Прологе есть каноническое представление. Если вы не уверены относительно структуры вашего терма, используйте `write_canonical/1` чтобы получить каноническое представление терма. Например:

    ?- write_canonical(a+b=[x,y,z]).
    =(+(a,b),'.'(x,'.'(y,'.'(z,[]))))

Каноническое представление удобно тем, что может быть с легкостью прочитано другими программами.