
# Многогранность Пролога #


## Пролог --- очень простой язык ##

Довольно просто описать синтакс Пролога, в деталях достаточных для полноценной работы с языком. Все данные представлены термами. В языке существует единственная конструкция --- !!утверждение!!. Утверждения имеют форму:

    Голова :- Тело.

Такая запись означает, что если `Тело` верно, то и `Голова` тоже верна. Инфиксный оператор `:-/2` символизирует стрелочку показывающую налево: `<-`. Если `Голова` верна всегда, то часть утверждения `:- Тело` может быть опущена.

Этого короткого описания вполне достаточно, чтобы начать писать полезные программы на Прологе. Это может показаться невероятным, так что для убедительности упомянем, что _все_ программы представленные в этой книге состоят исключительно из подобных утверждений. Более того, _любое_ вычисление может быть представлено в форме _утверждений_, что делает Пролог [тьюринг-полным](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D0%B0_%D0%BF%D0%BE_%D0%A2%D1%8C%D1%8E%D1%80%D0%B8%D0%BD%D0%B3%D1%83) языком.

Чтобы смоделировать машину Тьюринга на Прологе, можно, например, выразить все отношения между состояними машины с помощью _утверждений_ вида "если текущее состояние `S0`, и символ на ленте `T`, то слудующим состоянием будет `S`". Вы можете ознакомиться с имплементацией этой модели в [turing.pl](https://www.metalevel.at/prolog/showcases/turing.pl), и узнать больше про работу с состояним в Прологе в главе "[Работа с состояними]()".

## Пролог --- декларативный язык ##

Пролог --- декларативный язык. Это значит что мы большую часть времени уделяем описанию того, _что_ мы хотим найти. Мы стараемся выразить условия, которые отличают верные решения от неверных. Нам гораздо менее важно и интересно то, _как_ Пролог будет находить эти решения.

Декларативная природа Пролога позволяет выражать отношения в виде чётких, ясных и универсальных определений. Маловероятно, что возможен более лаконичный формализм, обладающий при этом такой же ясностью и выразительностью, как программы на Прологе.

Для примера опишем отношение между списком и его длиной используя целочисленную арифметику:

    список_длина([], 0).

    список_длина([_|Ls], N) :-
        N #> 0,
        N #= N0 + 1,
        список_длина(Ls, N0).

Возможно следующее декларативное прочтение:

- Длина пустого списка `[]` равна `0` (также как и список длины `0` пуст).
- Если длина списка `Ls` равна `N0`, и `N` равно `N0 + 1`, тогда длина списка `[_|Ls]` равна `N`. Это утверждение верно лишь при `N` строго большем нуля.

Про программировании на Прологе, важно думать в терминах отношений между элементами программы. С таким подходом к написанию программы получаются универсальными. Очень заманчиво назвать вышеприведённый пример "вычислением длины списка". И в определённой мере это верно: мы можем использовать отношение `список_длина` для вычисления длины списка:

    ?- список_длина([a, b, c], L).
    L = 3.

Однако подобное императивное прочтение однобоко и недостаточно подчёркивает все возможности использования нашего определения. Например, если задать конкретную длину списка, мы можем узнать, существуют ли списки такой длины:

    ?- список_длина(Ls, 3).
    Ls = [_G1007, _G1087, _G1167] ;
    false.

Используя наиболее общий вопрос, мы даже можем перебрать ответы, какие Пролог только может найти:

    ?- список_длина(Ls, L).

    Ls = [], L = 0 ;
    Ls = [_2130], L = 1 ;
    Ls = [_2130, _2668], L = 2 ;
    etc.

В этом случае мы говорим что отношение может быть !!использовано в различных направлениях!!. Заметим, что Пролог перебирает ответы используя _механизм отката_.

Предикат `length/2`, аналогичный нашему предикату `список_длина/2`, является частью проекта стандартной библиотеки [Prologue for Prolog](https://www.complang.tuwien.ac.at/ulrich/iso-prolog/prologue), и доступен как сиситемный предикат в почти всех известных реализациях Пролога.

## Пролог --- логический язык

Декларативные языки программирования делятся на два класса --- функциональные и логические. Функция --- это особенная форма отношения, и следовательно можно рассматривать функциональные языки как ограниченную версию языков логических. Программы на чистом прологе состоят из набора [хорновых предложений](https://ru.wikipedia.org/wiki/%D0%A5%D0%BE%D1%80%D0%BD%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9_%D0%B4%D0%B8%D0%B7%D1%8A%D1%8E%D0%BD%D0%BA%D1%82). Выполнение программ на Прологе является способом логического вывода, а сам алгоритм этого вывода базируется на формальной логике. В логических терминах, при поиске ответа Прологои, ищется опровержение _отрицания запроса_ и _утверждений программы_. Если опровержение найдено, то запрос является логическим следствием утверждений приведённых в программе.

Такая связь с формальной логикой позволяет нам применять мощные средства декларативной отладки, базирующихся на логических свойствах программы. Например, добавление ограничения к программе не может увеличить количество решений, а добавление новых утверждений не может уменьшить количество решений. Это свойство программ на _чистом Прологе_ называется !!монотонностью!!.

Программа [GUPU](https://www.complang.tuwien.ac.at/ulrich/gupu/), разработанная Ульрихом Ноймеркелем представляет собой впечатляющее применение этих идей.

## Пролог --- гомоиконный язык ##

> от греч. ὁμός — «равный», «одинаковый» и εἰκόνα — «о́браз», «изображение»

Программы на Прологе сами являются термами! Это является большим преимуществом Пролога перед многими другими языками --- ведь можно с лёгкостью писать программы которые анализируют, преобразуют и интерпретируют другие программы. Для чтения термов, а следовательно и утверждений, можно использовать встроенный предикат `read/1`.

В Пролог встроен мощный механизм преобразования программ во время компиляции, что позволяет определять собственные предметно-ориентированные языки, которые помогают более естественным образом отразить специфику решаемых с их помощью задач.

В это, возможно, сложно поверть, потому что одни цели --- такие как `список_длина(Ls, N)` --- выглядят как обычные термы, а другие --- такие как `N #> 0` --- совсем по-другому. Причиной этому является возможность определять _префиксные_, _инфиксные_ и _постфиксные_ операторы, которые позволяют записывать утверждения в более естественном для человека виде. Например, терм `+(a, b)` может быть записан в инфиксной форме как `a + b`.  При этом абстрактный синтакс Пролога остаётся совершенно униформным, и автоматической чтение и обработка термов на Прологе не зависит от формы записи.

Заметим, что в программах на Прологе можно определять новые операторы для собственных нужд.

## Пролог --- динамический язык ##

Во время выполнения программы на Прологе возможно сгенерировать, выполнить и изменить новую программу. Это ещё больше повышает выразительность языка и позволяет реализовать предикаты высшего порядка, принимающие в качестве аргументов другие предикаты. Это также позволяет реализовать очень динамичные алгоритмы, такие как адаптивный синтаксический анализ. Динамический характер Пролога делает язык идеально подходящим для написания программ, расширяемым по специальным правилам, предоставляемым другими программистами и даже обычными пользователями. [Proloxy](https://www.metalevel.at/proloxy/) и [Gerrit Code Review](https://www.gerritcodereview.com/) являются примерами такого подхода: для настройки этих программы используются правила записаные в форме утверждений на Прологе и выражающие требования пользователя очевидным и гибким способом. Дополнительная информация приведена в главе «[Мета-интерпретаторы]()».

> _Интерпретатор для чистого Пролога умещается в двух строках кода._

## Пролог --- разносторонний язык ##

Пролог --- исключительно разносторонний язык. Реляционная природа языка делает его гибким и универсальным, что важно при решении задач обработки естественного языка и представления знаний. Современный Пролог предоставляет всё необходимое для решения самых разнообразных задач, от логических головоломок, до построения масштабных приложений, от разработки интернет сайтов, до верификации и оптимизации.