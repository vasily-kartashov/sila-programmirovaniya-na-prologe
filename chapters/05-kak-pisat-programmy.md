# Как писать программы на Прологе

Самый лучший совет как писать код на Прологе был приведён Ричардом О`Кифе в его книге The Craft of Prolog:

> Элегантность не опциональна.

Следуйте этому совету! Если ваша программа на Прологе выглядит не элегантно, остановитесь и подумайте, как можно её улучшить. Эта глава содержит некоторые советы как следует писать код на Прологе.

## С чего начать?

Рассмотрим снова определение предиката `список_список_объединение/3`, который был рассмотрен в предыдущей главе. Как самому придти к такому определению?

Когда вы пишете предикат на Прологе, думайте о том, при каких условиях он должен быть верным. Например, в случае с предикатом `список_список_объединение/3`, мы можем рассудить следующим образом: во-первых, мы хотим описать отношение между списками. Из рекурсивного определения списка мы знаем, что нам необходимо будет рассмотреть по крайней мере два разных случая:

- пустой список, представленный атомом `[]`
- составной терм в форме `[L|Ls]`

Эти два случая образуют "скелет" определения нашего предиката:

    список_список_объединение([], Bs, Cs) :-
        ...
    список_список_объединение([L|Ls], Bs, Cs) :-
        ...

Эти два правила соответствуют двум случаям, которые у нас возникли, а именно пустому и непустому спискам в качестве первого аргумента. Зададим себе вопрос: при каких условиях верны эти два правила. Подумав можно заметить, что первое правило верно, если `Bs = Cs`. Мы можем записать это правило так:

    список_список_объединение([], Bs, Cs) :-
        Bs = Cs.

Подобную унификацию можно перенести в голову предложения, и переписать правило в форме факта:

    список_список_объединение([], Bs, Bs).

Применим тоже самое рассуждение и ко второму правилу: при каких условиях верно, что `Cs` является объединением списков `[L|Ls]` и `Bs`? Минутное раздумье подскажет нам: это верно, если `Cs` имеет вид `[L|Rest]`, а `Rest` --- это объединение `Ls` и `Bs`. Мы используем встроенный предикат `(',')/2`, чтобы выразить эту конъюнкцию условий. Чтобы описать, что `Rest` является конкатенацией `Ls` и `Bs`, мы используем `список_список_объединение(Ls, Bs, Rest`), так как это именно то отношение, которое должно быть выполнено в этом случае.

Полное утверждение примет следующий вид:

    список_список_объединение([L|Ls], Bs, Cs) :-
        Cs = [L|Rest],
        список_список_объединение(Ls, Bs, Rest).

Это пример предиката, чьё определение ссылается на самого себя. Подобные предикаты называются рекурсивными.
Обратите внимание, как естественно возникают рекурсивные определения при рассмотрении условий, которые делают такие предикаты истинными.

Как и прежде унификацию можно перенести в голову правила, упростив тем самым его запись:

    список_список_объединение([L|Ls], Bs, [L|Rest]) :-
        список_список_объединение(Ls, Bs, Rest).

В качестве упражнения читатель может попробовать подобрать более удачные имена для переменных.

Когда новички только начинают писать свои первые программы на Прологе, одна из распространенных ошибок заключается в том, чтобы задать неправильный вопрос: «Что должен делать Пролог в этом случае?». Этот вопрос ошибочен: особенно для новичка, понять фактический поток управления для разных способов вызова совешенно невозможно. Да и сам этот вопрос обычно ограничивает вас только одним возможным режимом использования вашего предиката. Поэтому не попадайте в эту ловушку! Вместо этого подумайте об условиях, которые делают отношение верным, и дайте чёткое декларативное описание этих условий. Если вам удастся правильно сформулировать эти условия, вы часто, естественно, получаете очень общие предикаты, которые можно использовать в нескольких направлениях. Таким образом, при написании кода Пролога лучше спросите: в каких случаях и при каких условиях предикат верен?

Вы можете подумать: всё это, конечно, здорово и работает для простеньких отношений. Но что, если я хочу на самом деле «что-то сделать», например, увеличить счетчик, удалить элемент и т. д.? Ответ на этот вопрос всё тот ​​же: подумайте о взаимоотношениях между сущностями, которые вы описываете. Чтобы выразить какую-либо модификацию, вы должны определить отношение между различными состояниями чего-либо и указать условия, при которых это отношение истинно. Глава «[Работа с состояними]()» содержит дополнительную информацию.

## Выбор имени для предикатов

Хорошее имя предиката подсказывает роль каждого аргумента. В идеале предикат может быть использован во всех направлениях. Это означает, что любой аргумент может быть переменной --- частично или полностью связанной. Эта гибкость должна быть выражена в имени предиката, обычно путем выбора существительных для описания аргументов.

Примеры удачных имён:

- `список_длина/2`, связывает список с его длиной
- `целое_слудующее/2`, свазывает целое число с числом следующим за ним
- `студент_курс_оценка/3`, связывает студентов с курсами, которые они посещают, и полученными там оценками.

В этих случаях имена предикатов настолько ясны, что дополнительные описания кажутся излишними. Заметим также что длинные_имена_использующие_знак_подчёркивания_читаются_легко, а вот именаНаписанныеСлитноВРазныхРегистрахЧитаютсяЗначительноТруднее.

По этим причинам можно назвать следующие примеры менее удачными:

- `длина/2`: Каким по порядку аргументом идёт длина, первым или вторым?
- `следущееЦелое/2`: Не так легко прочесть, как `следущее_целое/2`, и не так легко понять как `целое_следущее/2`.
- `прочесть_оценки/3`: Бессмыслица в случае, если оценки уже связанные переменные.

## Именование переменных

Имена переменных в Прологе дожны начинаться либо с заглавной буквы, либо со знака подчёркивания. Последнее правило полезно знать, если вы, например, преподаёте Prolog в Японии. В отличии от имён предикатов, имена переменных в Прологе иногда записывают в СмешаныхРегистрах. Тем не менее, почти во всех случаях такие имена переменных состоян не более чем двух слитно написанных слов.

Некоторые предикаты Пролога описывают последовательность изменения состояний, чтобы выразить изменение состояния чистым способом. В таких случаях может быть очень полезно следующее соглашение: начальное состояние обозначается как `Состояние0`, следующее за ним состояние --- `Состояние1` и т. д. Это перечисление продолжается до конечного состояния, которое мы называем `Состояние`. Полностью последовательность будет выглядеть следующим образом:

    Состояние0 -> Состояние1 -> ... -> Состояние


Конечно, префикс Состояние может обозначать любую другую сущность, которая описывается предикатом. Например, если несколько элементов вставляются в ассоциациативный список, мы можем иметь последовательность:

    Словарь0 -> Словарь1 -> ... -> Словарь

При написании предикатов более высокого порядка, хорошей практикой является обозначить с `C_N` лямбду `C`, которое вызывается с `N` дополнительными аргументами. Например, первый аргумент `maplist/2` можно назвать `Pred_1`, потому что он вызывается с одним дополнительным аргументом

## Отступы

Пролог очень простой язык: есть весьма ограниченный набор языковых конструктов, и несколько общепринятых способов отступа. Однако, независимо от стандарта оформления кода, всегда следует придерживаться одного золотого правила, а именно, никогда не ставить `(;)/2` в конце строки. Иначе точку с запятой ";" будет легко спутать с запятой ",", а поскольку `,/2` сама почти всегда встречается в конце строки, хорошей практикой будет поместить ";" либо в начале строки, либо посреди между двумя целями дизъюнкции, так, чтобы её лечге было отличить от конъюнкции.

## Дополнительные материалы

Covington et al., Coding Guidelines for Prolog, содержит несколько интересных наблюдений касательно программирования на Прологе.
